---
title: "Exploring Community Trend (WHI Pre-pilot) Study Summary 1: Cleaning & Scoring"
author: "Kristina Dale"
date: ""
output:
  html_document:
    code_folding: hide
    df_print: paged
    highlight: tango
    theme: united
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  github_document:
    toc: true
    toc_depth: 2
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
options(scipen=999)
```

# Scope
1. Basic cleaning of survey data
- Summary of survey completion
- Survey data coding & scoring
    
2. Basic cleaning of moment data
- Summary of moment completion
- Moment "scoring"
  
Outputs include:

1. cleaned survey data - csv 
- dictionary - csv
2. scored survey - csv
- dictionary - csv
3. cleaned moments - csv
4. merged data file (survey+moments) - csv 

scored survey data --> standardization + codebook

cleaned moments --> master (to be processed by DS)

Accompanying files:

1. Study Summary 2: Summary & Descriptive Statistics 
    - uses standardized scored survey & standardized(?) scored moments
  
# load packages
```{r}
if(!require('pacman')) {
	install.packages('pacman')
}

pacman::p_load(tidyverse, labelled, devtools, haven, expss, DT, qwraps2, remotes, readxl, retidytext, openxlsx, reactable, reactablefmtr, ggwordcloud, topicmodels,here,psych,rio, install = TRUE)
```

# define aesthetics
```{r}
palette = c("#772e25", "#c44536", "#ee9b00", "#197278", "#283d3b", "#9CC5A1", "#ADA7C9", "grey50")
palette_type = c("#c44536", "#ee9b00", "#197278")
palette_pilot = c("#c44536", "#197278")
palette_sentiment = c(palette[2], palette[4])
plot_aes = theme_minimal() +
  theme(legend.position = "top",
        legend.text = element_text(size = 8),
        text = element_text(size = 12, family = "Futura Medium"),
        axis.text = element_text(color = "black"),
        axis.ticks.y = element_blank())
```

# define variables & directory

```{r}
survey_name_1 <- "whi_all_states"
raw_file_name_1 <- "Exploring Community Trends Pre-Pilot_August 10, 2023_08.35.sav"
survey_name_2 <- "whi_arkansas_sub"
raw_file_name_2 <- "Exploring Community Trends Pre-Pilot - AR_August 10, 2023_08.38.sav"

prolific_user_file_1 <- "allstates_prolific_export_6430a3fdcea4949acc8d92b1(2).csv"
prolific_user_file_2 <- "arkansas_prolific_export_6431c55de649991aa28374b3 (1).csv"
prolific_id_length <- 24

first_survey_var <- "QOL_1"
last_survey_var <- "SF36_36"
```

# define functions
```{r}
value_between <- function(vec, start, end){
  
  result <- vec[(which(vec == start)):(which(vec == end))]
  
  return(result)
}
```

# Basic Cleaning -- survey
1. load & deidentify data 
- Prolific status check -- merge & address data deletion
2. deduplication + duplicate summary
3. summarize consent, terms & NDA (where applicable) + additional participant "electives" (e.g., here "content_recruit")
4. attention checks & recording test
5. write cleaned csv + dictionary 
 
# load & de-identify Qualtrics data 
There were 2 identical surveys launched for this study, 1 open to multiple states, 1 open only to Arkansas residents only -- see the study detail page & outline for details.   
    
All states datasets contains 956 observations. Arkansas subsets contains 34 observations. After excluding testing cases, 974 observations are included in the merged dataset.
```{r}
######## all_states
#all_states <- rio::import("/Users/kristina/Documents/Surveys/NEW /WHI Exploring Comm Trends/USE THIS/Raw data/Exploring Community Trends Pre-Pilot_August 10, 2023_08.35.sav")
all_states <- import(here::here("inputs", raw_file_name_1))
all_states$survey_name <- survey_name_1

######## arkansas_sub
#arkansas_sub <- read_sav("/Users/kristina/Documents/Surveys/NEW /WHI Exploring Comm Trends/USE THIS/Raw data/Exploring Community Trends Pre-Pilot - AR_August 10, 2023_08.38.sav")

arkansas_sub <- import(here::here("inputs", raw_file_name_2))
arkansas_sub$survey_name <- survey_name_2

# merge the two datasets
survey <- full_join(all_states, arkansas_sub)

#missing ID check
plyr::count(survey$PROLIFIC_PID=="")
survey$PROLIFIC_PID <- ifelse(survey$PROLIFIC_PID == "", survey$Prolific_ID, survey$PROLIFIC_PID)
plyr::count(survey$PROLIFIC_PID=="")
survey$PROLIFIC_PID <- ifelse(survey$PROLIFIC_PID == "", survey$ID_check, survey$PROLIFIC_PID)
plyr::count(survey$PROLIFIC_PID=="")

subset(survey, survey$PROLIFIC_PID=="") #confirm any missing IDs are blank data

survey_filtered <- survey %>%
  filter(!PROLIFIC_PID == "") %>% # remove test responses
  filter(nchar(PROLIFIC_PID) == prolific_id_length) %>%
  filter(!DistributionChannel == "Preview") %>% # remove incomplete responses
  select(-c(StartDate, EndDate, Status, Finished, RecipientLastName,  IPAddress,RecipientFirstName, RecipientEmail, LocationLatitude, LocationLongitude, DistributionChannel, UserLanguage)) %>% #remove cols #de-identify
  dplyr::rename(userid = PROLIFIC_PID) %>% # standardize userIDs
  select(userid, everything()) %>% # move userID to the front
  mutate(across(where(is.character), ~na_if(., ""))) #convert empty cell into NAs

# add labels 
attr(survey_filtered$userid, "label") <- "User IDs that can be used for data merging"

```

## Prolific status check 

Records from 746 participants are included in the prolific dataset. Among them, 2 participants don't have matching data from the survey dataset, and both of them revoked their consent. 196 observations from 184 participants in the survey dataset don't have matching data in the prolific dataset. Their prolific_status will be marked as "TIMEOUT" 
```{r}
#prolific_all_states <- read.csv("/Users/kristina/Documents/Surveys/NEW /WHI Exploring Comm Trends/USE THIS/Raw data/allstates_prolific_export_6430a3fdcea4949acc8d92b1 (2).csv")
#prolific_arkansas_subset <- read.csv("/Users/kristina/Documents/Surveys/NEW /WHI Exploring Comm Trends/USE THIS/Raw data/arkansas_prolific_export_6431c55de649991aa28374b3 (1).csv")


prolific_all_states <- read.csv(here::here("inputs",prolific_user_file_1))
prolific_arkansas_subset <- read.csv(here::here("inputs",prolific_user_file_2))

# merge the two prolific datasets
prolific <- bind_rows(prolific_all_states, prolific_arkansas_subset)

# tidy prolific dataset
prolific_tidy <- prolific %>%
  rename_all(~paste0(., "_prolific")) %>% # add suffix
  dplyr::rename(userid = Participant.id_prolific) %>% # standardize user IDs name
  dplyr::mutate(across(where(is.character),  # recode null data into NA 
                       ~  case_when(
                              . == "DATA_EXPIRED" ~ NA,
                              . == "Prefer not to say" ~ NA,
                              TRUE ~ .)))

# merge with survey data
survey_merged <- survey_filtered %>% left_join(prolific_tidy, by = "userid") %>%
  mutate(Status_prolific = replace_na(Status_prolific, "TIMEDOUT"))

# check participants from the prolific file that can't match in the survey data file
prolific_notmatch <- anti_join(prolific_tidy, survey_filtered, by = "userid")
# check observations from the survey data file that can't match in the prolific file
survey_notmatch <- anti_join(survey_filtered, prolific_tidy, by = "userid")

# check number of subjects missing from prolific
length(unique(survey_notmatch$userid))

# flag non-matched observations
prolific_notmatch_id <- unique(prolific_notmatch$userid)
survey_notmatch_id <- unique(survey_notmatch$userid)

survey_match_f <- survey_merged %>%
  mutate(flag_nomatch_prolific = case_when(userid %in% prolific_notmatch_id ~ TRUE,
                                   TRUE ~ FALSE), 
         flag_nomatch_survey = case_when(userid %in% survey_notmatch_id ~ TRUE,
                                   TRUE ~ FALSE))

attr(survey_match_f$flag_nomatch_prolific, "label") <- "TRUE if the observation is included in the prolific file but not in the survey data file"
attr(survey_match_f$flag_nomatch_survey, "label") <- "TRUE if the observation is included in the survey data file but not in the prolific file"
```

## Consent & Terms
7 participants (no duplicate IDs) revoked consent or did not complete consent upon entering the study. These participant IDs are removed, leaving 983 total observations. 

8 participants returned the study in Prolific, effectively revoking consent. There are various reasons for a user to return their survey, which are detailed below where possible. Data coming from these users is removed from the dataset here.  
*notes for iteration: (1) will want to probably merge other data (moments etc) before this step so all data is removed/accounted for (2) can add details via excel import/merge of notes?*
```{r clean consent} 
# remove data from revoked consent
survey_cleaned = survey_match_f %>%
  filter(!Status_prolific == "RETURNED") %>% # remove returned surveys
  filter(Consent_confirm == 1) # only include data from confirmed consent

#summarize returned responses
data_remove <- survey_merged %>%
  select(userid, Status_prolific, Submission.id_prolific) %>%
  unique() %>%
  filter(Status_prolific =="RETURNED") %>%
  group_by(userid, Status_prolific,Submission.id_prolific) %>%
  mutate(detials = "") 
data_remove<- data_remove[order(data_remove$userid),]

data_remove 

survey_merged %>%
  select(userid, Status_prolific) %>%
  group_by(Status_prolific) %>%
  mutate(count = length(Status_prolific)) %>%
  dplyr::summarize(n = n()) %>%
  spread(Status_prolific, n) %>%
  mutate(percent_approved = round((APPROVED/ nrow(survey_merged)) * 100, 1)) %>%
  mutate(percent_available = round(((APPROVED+TIMEDOUT)/nrow(survey_merged)) * 100, 1))
```


## Summarize qualtrics: consent, terms agreement, NDA, attention checks, recording tests, etc {.tabset}

### deduplication & duplicates summary
There were 124 total duplicate reponses, from 50 unique participants, **thus in this study, data was collected from 909 unique participants**. Duplication in survey data could have happened if the participant accessed and started the Qualtrics study multiple times. Here, we retain all duplicated data and flag each response, responses are also flagged based on completion. See below for details.

```{r flag duplication}
survey_dupe_f <- survey_cleaned %>%
  group_by(userid) %>%
  mutate(flag_dupe_survey = duplicated(userid) | rev(duplicated(rev(userid)))) %>% # flag rows with identical userid
  dplyr::mutate(
  max_progress = max(Progress),
  distinct_progress = n_distinct(Progress),
  total_rows = nrow(.)) %>%
  mutate(
    flag_most_complete_survey = case_when(
      # Unique userid cases
      flag_dupe_survey == F ~ "TRUE",
      
      # Duplicated userid but identical progress
      flag_dupe_survey == T & total_rows > 1 & distinct_progress == 1 ~ "SAME",
      
      # Duplicated userid with non-identical progress
      flag_dupe_survey == T & Progress == max_progress & distinct_progress > 1 ~ "TRUE",
      flag_dupe_survey == T & Progress != max_progress & distinct_progress > 1 ~ "FALSE",
      
      TRUE ~ NA_character_
    )
  ) %>%
  select(-max_progress, -distinct_progress, -total_rows) %>%
  ungroup()

attr(survey_dupe_f$flag_dupe_survey, "label") <- "TRUE: data from userid that have more than 1 occurrence; FALSE: data from unique userid"
attr(survey_dupe_f$flag_most_complete_survey, "label") <- "TRUE: data from unique userid or has the highest progress among duplicated responses; FALSE: duplicated responses that don’t have the highest progress; SAME: duplicated response that share the same progress"

table(survey_dupe_f$flag_dupe_survey)
length(unique(survey_dupe_f[survey_dupe_f$flag_dupe_survey == TRUE,]$userid))
```

### Failed recording test
14 participants failed the recording test, 29 had missing data. 

The `flag_failed_recording_test` marks if the parcipants failed the recording test, retaining NA/missing. 
```{r flag failed testing}

survey_dupe_f %>%
  select(survey_name, userid, Recording_test) %>%
  unique() %>%
  gather(Recording_test, value, Recording_test) %>%
  filter(is.na(value)|value!=1) %>%
  group_by(Recording_test, survey_name, value) %>%
  dplyr::summarize(n = n())

survey_record_f <- survey_dupe_f %>%
  mutate(flag_failed_recording_test = case_when(Recording_test == 0 ~ TRUE, 
                                                Recording_test == 1 ~ FALSE,
                                                TRUE ~ NA))

attr(survey_record_f$flag_failed_recording_test, "label") <- "TRUE if participants failed teh recording test. NAs were retained"

```

### Failed attention 
No attention checks were included in this study

## Additional data screening {.tabset}

### Missing all survey data

120 observations didn't provide any survey item data
```{r flag no survey data}
# extract survey item variables
survey_var <- value_between(colnames(survey_cleaned), first_survey_var, last_survey_var)

# flag observations with no survey data
survey_survey_f <- survey_record_f %>%
  mutate(flag_no_survey = (rowSums(is.na(dplyr::select(., all_of(survey_var)))) == length(dplyr::select(., all_of(survey_var)))))

table(survey_survey_f$flag_no_survey, useNA = "ifany")

attr(survey_survey_f$flag_no_survey, "label") <- "TRUE if participants didn't provide any survey data; FALSE if at least 1 survey item was recorded"
```

### Data quality: repetitive responses in a sequence

We want to flag participants who provided identical responses in a long sequence. The highest percentage of identical sequence is 12%, which is within a reasonable range
```{r screen repetitive responses}
# calculate the number of survey item 
item_n <- ncol(select(survey_survey_f, all_of(survey_var)))

survey_screen <- survey_survey_f %>%
  mutate(max_identical = apply(select(., all_of(survey_var)), 1, function(x) {max(rle(x)$lengths)}), 
         max_identical_perc = round((max_identical/item_n)*100))

describe(survey_screen$max_identical_perc)

attr(survey_screen$max_identical, "label") <- "The number if identical survey responses in a seqeunce"
attr(survey_screen$max_identical_perc, "label") <- "The perceptage of identical survey responses in a seqeunce out of all survey items"
```

### Study duration

check the distribution of survey duration among those who completed the survey within 2 hours. The expected completion time was 60 minutes. 
```{r screen duration}
# subset completed observations
survey_complete <- survey_screen %>%
  filter(flag_most_complete_survey!="FALSE") %>% #filter dupes & no survey data
  mutate(Progress = ifelse(Progress == 100, "complete", "incomplete")) %>%
  filter(Progress == "complete") %>%
  mutate(duration = Duration__in_seconds_/60) # transform survey durection into minutes

# check overall duration
describe(survey_complete$duration)

# check duration distribution within 2 hours
hist(survey_complete[survey_complete$duration < 120,]$duration)

```

To further examine those responses with a completion time of less than 10 minutes, we pair these data with other data screening results. People who spent too little time on the survey didn't provide any survey data 
```{r screen duration cont}
survey_complete %>%
  filter(duration < 10) %>%
  select(flag_no_survey, duration, flag_failed_recording_test,max_identical_perc)
```

## Summarize data screening results

Based on all data screening efforts, 845 observations are recommended to include in the analysis. Criteria include:
- at least some survey data
- is the most completed survey if there were duplicates. 

These column identified as "recommended for analyses" are flagged in the `flag_rec_include` column
```{r flag recommended obaservation}
  
# mark the observation
survey_tidy <- survey_screen %>%
  mutate(flag_rec_include = case_when(flag_most_complete_survey != FALSE & flag_no_survey == FALSE ~ TRUE,
          TRUE ~ FALSE))

table(survey_tidy$flag_rec_include, useNA = "ifany")

# add labels
attr(survey_tidy$flag_rec_include, "label") <- "TRUE if WB team recommend to include this observation. Criteria include:- at least some survey data
- did not failed both attention check questions 
- is the most completed survey if there were duplicates. "
```


# Summarize qualtrics completion info {.tabset}
## full data
Overall, there are 784 cases of complete data, when accounting for duplicates, ~83% completion overall. 
```{r screen completion}
survey_tidy %>%
  select(survey_name, userid, Progress) %>%
  mutate(Progress = ifelse(Progress == 100, "complete", "incomplete")) %>%
  group_by(Progress) %>%
    mutate(count = length(survey_name)) %>%
  dplyr::summarize(n = n()) %>%
  spread(Progress, n) %>%
  mutate(percent_complete = round((complete / (complete+incomplete)) * 100, 1))

```
## no dupes
```{r screen completion no dup}
survey_tidy %>%
  select(survey_name, userid, Progress, flag_most_complete_survey) %>%
  filter(flag_most_complete_survey!="FALSE") %>% #filter dupes 
  mutate(Progress = ifelse(Progress == 100, "complete", "incomplete")) %>%
  group_by(Progress) %>%
    mutate(count = length(survey_name)) %>%
  dplyr::summarize(n = n()) %>%
  spread(Progress, n) %>%
  mutate(percent_complete = round((complete / (complete+incomplete)) * 100, 1))
```

## select data that need to be manually checked on prolific

These are the observations in the survey data that are not included in the downloaded prolific dataset but provide at least some valid data. We have 91 observations from 91 participants that need to be checked on prolific
```{r}
survey_tidy <- survey_tidy %>%
  mutate(flag_prolific_check = case_when(flag_nomatch_survey == TRUE & flag_no_survey == FALSE ~ TRUE,
                                         TRUE ~ FALSE))

prolific_check_df <- filter(survey_tidy, flag_prolific_check == TRUE) %>%
  select(userid, flag_nomatch_survey, flag_no_survey, Progress, Duration__in_seconds_, Status_prolific)

attr(survey_tidy$flag_prolific_check, "label") <- "TRUE if the observation includes at least one valid survey item response  but can't find a match in the prolific dataset"

#write.csv(prolific_check_df, here("outputs", "whi_prolific_check_df.csv"), row.names = F)
```



# code & score qualtrics data {.tabset}
1. recode demographics/qual items to character
2. psychological surveys
- [QOL:Quality of life - adapted](https://www.google.com/url?q=https://toolbox.naccho.org/api/ToolBlob?blobKey%3D9ad42923-f23a-4d0a-bbd2-8c30f5eadf65%26fileName%3DQuality%2520of%2520Life%2520Survey%2520Questions_2.pdf&sa=D&source=docs&ust=1683130924596966&usg=AOvVaw1Tto4bQFFAIk_kKuoz4h49)
- [SDOH: Social determinants of health - adapted](https://innovation.cms.gov/files/worksheets/ahcm-screeningtool.pdf)
- [AB:Access & Barries - adapted](https://nwacouncil.org/wp-content/uploads/2021/01/NWAHealthcareAssessmentOnlineVersion.pdf)
  - NOTE: AB_AK items only included in arkansas subset version
- [CH: Core health - adapted](https://www.cdc.gov/brfss/questionnaires/pdf-ques/2021-BRFSS-Questionnaire-1-19-2022-508.pdf)
- [PRBQ: Risky Behaviors](https://istss.org/getattachment/Clinical-Resources/Assessing-Trauma/Posttrauma-Risky-Behaviors-Questionnaire-(PRBQ)/Posttrauma-Risky-Behaviors-Questionnaire.pdf?lang=en-US)
- [SF-36: Subjective Meantal/Physical Health](https://www.rand.org/health-care/surveys_tools/mos/36-item-short-form/scoring.html)

## recode numeric to character
recoded from numeric to character; parse race/ethnicity variables; parse county variables; add labels 
kristina note for bernice: you lose the column labels here for some variables
```{r k_edit}
# generate a dictionary
survey_tidy_dict <- create_dictionary(survey_tidy, remove_repeated = F, use_references = F)

# transform the dictionary into a list 
dict_list <- split(select(survey_tidy_dict, -meta), survey_tidy_dict$variable)

# extract all variable numbers for the "select all that apply" questions
varname <- names(dict_list)

# all demographics & additional qualitative items from the survey
demo_idx <- which(grepl("Demo_", varname))
county_idx <- which(grepl("_county", varname))
state_idx <- which(grepl("state", varname))
AB_idx <- which(grepl("AB", varname))
CH_idx <- which(grepl("CH_", varname))
SDOH_idx <- which(grepl("SDOH_", varname))

multi_resposne_idx <- c(demo_idx, county_idx,state_idx,AB_idx,CH_idx,SDOH_idx)

# subset these variables from the dictionary list
recode_dict_list <- dict_list[multi_resposne_idx]

# replace response with variable label 
surveys_scored <- survey_tidy
surveys_scored[names(recode_dict_list)] <- Map(function(x, y) { 
    tmp <- with(y,  setNames(label, value)[as.character(x)])
     tmp[is.na(tmp)] <- x[is.na(tmp)]
     tmp}, survey_tidy[names(recode_dict_list)], recode_dict_list)

```

## recode county
```{r}
surveys_scored$county <- ifelse(!is.na(surveys_scored$AK_county), surveys_scored$AK_county,
                      ifelse(!is.na(surveys_scored$TX_county), surveys_scored$TX_county,
                      ifelse(!is.na(surveys_scored$ID_county), surveys_scored$ID_county,
                      ifelse(!is.na(surveys_scored$IA_county), surveys_scored$IA_county,
                      ifelse(!is.na(surveys_scored$NC_county), surveys_scored$NC_county,
                      ifelse(!is.na(surveys_scored$IN_county), surveys_scored$IN_county,
                      ifelse(!is.na(surveys_scored$KY_county), surveys_scored$KY_county,
                      ifelse(!is.na(surveys_scored$WI_county), surveys_scored$WI_county,
                      ifelse(!is.na(surveys_scored$WA_county), surveys_scored$WA_county, NA)))))))))
#surveys_scored <- surveys_scored[c(1:12,266,13:265)]
# surveys_scored <- surveys_scored %>% select(-contains("_county")) # similarly, we keep all the raw data from the dataset

```

## recode demographics
recoded from numeric to character; parse race/ethnicity variables 
```{r}
surveys_scored <- surveys_scored %>%
  dplyr::mutate(across(starts_with("Demo_") , ~ case_match(., "I prefer not to answer" ~ NA_character_,
                                                           .default = .))) %>% # convert all "I prefer not to answer" to NAs
  mutate(demo_race_combine = case_when( # coalesce race
    rowSums(!is.na(select(., Demo_ethnicity_1:Demo_ethnicity_7, -Demo_ethnicity_3))) == 0 ~ NA_character_,
    rowSums(!is.na(select(., Demo_ethnicity_1:Demo_ethnicity_7, -Demo_ethnicity_3))) == 1 ~ as.character(do.call(coalesce, select(., Demo_ethnicity_1:Demo_ethnicity_7, -Demo_ethnicity_3))),
    rowSums(!is.na(select(., Demo_ethnicity_1:Demo_ethnicity_7, -Demo_ethnicity_3))) > 1 ~ "multiracial")) %>% # ethnicity is not considered for multiracial
  dplyr::mutate(demo_ethnicity = Demo_ethnicity_3) #can't use rename because the attribution assignment will run into problems if all original

attr(surveys_scored$demo_race_combine, "label") <- "coalesced responses of the question 'Please specify your race and/or ethnicity.''multiracial' if multiple categories were selected. (Latinx/Hispanic was not included)"
attr(surveys_scored$demo_ethnicity, "label") <- "whether particpants self-identify as Latinx/Hispanic, Is not coalesed with racial categories"
```

## coalesce multiple responses (select all that apply items)
kristina note for bernice: not sure what to do with AB_2 and AB_33 (pick 3 from list)
```{r}
surveys_scored <- surveys_scored %>%
   mutate(
          arkansas_HC_location_AB_AK_combine = case_when(
            rowSums(!is.na(select(., AB_AK_1:AB_AK_13))) == 0 ~ NA_character_,
            rowSums(!is.na(select(., AB_AK_1:AB_AK_13))) == 1 ~ as.character(do.call(coalesce, select(., AB_AK_1:AB_AK_13))),
            rowSums(!is.na(select(., AB_AK_1:AB_AK_13))) > 1 ~ "multi"), 
          
          healthy_needs_AB_3_combine = case_when(
            rowSums(!is.na(select(., AB_3_1:AB_3_23))) == 0 ~ NA_character_,
            rowSums(!is.na(select(., AB_3_1:AB_3_23))) == 1 ~ as.character(do.call(coalesce, select(., AB_3_1:AB_3_23))),
            rowSums(!is.na(select(., AB_3_1:AB_3_23))) > 1 ~ "multiple"), 
          
          adult_HC_barriers_AB_4_combine = case_when(
            rowSums(!is.na(select(., AB_4_1:AB_4_9))) == 0 ~ NA_character_,
            rowSums(!is.na(select(., AB_4_1:AB_4_9))) == 1 ~ as.character(do.call(coalesce, select(., AB_4_1:AB_4_9))),
            rowSums(!is.na(select(., AB_4_1:AB_4_9))) > 1 ~ "multiple"),
          
         adult_mentalHC_barriers_AB_5_combine = case_when(
            rowSums(!is.na(select(., AB_5_1:AB_5_9))) == 0 ~ NA_character_,
            rowSums(!is.na(select(., AB_5_1:AB_5_9))) == 1 ~ as.character(do.call(coalesce, select(., AB_5_1:AB_5_9))),
            rowSums(!is.na(select(., AB_5_1:AB_5_9))) > 1 ~ "multiple"),
          
          child_mentalHC_barriers_AB_6_combine = case_when(
            rowSums(!is.na(select(., AB_6_1:AB_6_10))) == 0 ~ NA_character_,
            rowSums(!is.na(select(., AB_6_1:AB_6_10))) == 1 ~ as.character(do.call(coalesce, select(., AB_6_1:AB_6_10))),
            rowSums(!is.na(select(., AB_6_1:AB_6_10))) > 1 ~ "multiple"),
         
             teleheath_barriers_AB_7_combine = case_when(
            rowSums(!is.na(select(., AB_7_1:AB_7_10))) == 0 ~ NA_character_,
            rowSums(!is.na(select(., AB_7_1:AB_7_10))) == 1 ~ as.character(do.call(coalesce, select(., AB_7_1:AB_7_10))),
            rowSums(!is.na(select(., AB_7_1:AB_7_10))) > 1 ~ "multiple"))

# add labels to new data
attr(surveys_scored$arkansas_HC_location_AB_AK_combine, "label") <- "In the last 12 months, have you or people in your household gotten health services at any of the places below? Choose all that apply"
attr(surveys_scored$healthy_needs_AB_3_combine, "label") <- "Which of the things below would help you or others in your household to get healthy or stay healthy? Please select all that apply"
attr(surveys_scored$adult_HC_barriers_AB_4_combine, "label") <- "In the last 12 months, which of these problems kept you or other adults in your household from getting the health care or medicine you needed? (Choose all that apply)"
attr(surveys_scored$adult_mentalHC_barriers_AB_5_combine, "label") <- "In the last 12 months, which of these problems kept you or other adults in your household from getting the mental health care you needed? (Choose all that apply)"
attr(surveys_scored$child_mentalHC_barriers_AB_6_combine, "label") <- "In the last 12 months, which of these problems kept children in your household from getting the mental health care they needed? (Choose all that apply)"
attr(surveys_scored$teleheath_barriers_AB_7_combine, "label") <- "In the last 12 months, which of these problems kept you or anyone in your household from getting a telehealth or video visit with a health care worker? Choose all that apply"
```

## coalesce multiple responses (pick 3 most important/top 3)

We asked the participants to select 3 important things for AB_2 and select top 3 for AB_33, but the questions on qualtric did not force the number of checked options. All raw data are kept in the dataset, therefore, we only keep the first 3 checked options as the processed data. 
```{r}
# organize AB_2 question

AB_2_response <- surveys_scored %>%
  select(contains("AB_2"), userid) %>% # extract relevant data
  gather(-userid, key = "option", value = "select") %>% # transform to long-format
  filter(!is.na(select)) %>%  # only keep the selected onces
  group_by(userid) %>%
  dplyr::mutate(col_name = paste0("AB_2_important_", dplyr::row_number())) %>% # labeled the selected ones as option_1, option_2 & option_3
  dplyr::ungroup() %>%
  select(-option) %>%
  spread(col_name, select) %>% # transform the long-format back to a wide-format
  select(userid,AB_2_important_1,AB_2_important_2, AB_2_important_3) # because the survey asked to select 3 important options so all other transformed rankings were removed from the dataset

# organize AB_33
AB_33 <- surveys_scored %>%
  select(starts_with("AB33_"), userid) %>% # extract relevant data
  gather(-userid, key = "option", value = "select") %>% # transform to long-format
  filter(!is.na(select)) %>%  # only keep the selected onces
  group_by(userid) %>%
  dplyr::mutate(col_name = paste0("AB_33_rank_", dplyr::row_number())) %>% # labeled the selected ones as option_1, option_2 & option_3
  dplyr::ungroup() %>%
  select(-option) %>%
  spread(col_name, select) %>% # transform the long-format back to a wide-format
  select(userid, AB_33_rank_1,AB_33_rank_2, AB_33_rank_3) # because the survey asked to select the top 3 so all other transformed rankings were removed from the dataset

# merged the organized resonses back to the dataset
surveys_scored <- surveys_scored %>%
  left_join(AB_2_response, by = "userid") %>%
  left_join(AB_33, by = "userid")

# add labels
attr(surveys_scored$AB_2_important_1, "label") <- "The most important things the health care organizations are working on"
attr(surveys_scored$AB_2_important_2, "label") <- "The second important things the health care organizations are working on"
attr(surveys_scored$AB_2_important_3, "label") <- "The third important things the health care organizations are working on"

attr(surveys_scored$AB_33_rank_1, "label") <- "The top thing that would help you or others in your household to get healthy or stay healthy"
attr(surveys_scored$AB_33_rank_2, "label") <- "The second thing that would help you or others in your household to get healthy or stay healthy"
attr(surveys_scored$AB_33_rank_3, "label") <- "The third thing that would help you or others in your household to get healthy or stay healthy"
```


##labels
note for bernice - we lose a bunch of labels in the above chunk for the AB vars, the CH vars and the SDOH vars (noted there) not sure how you want to address it, here im just labeling the `age_house` variables . theres an outline that can probably be used to relabel manually 

```{r}
# attr(surveys_scored$Demo_age_house_1, "label") <- "Number of individuals in household 0-17 years"
# attr(surveys_scored$Demo_age_house_2, "label") <- "Number of individuals in household 18-39 years"
# attr(surveys_scored$Demo_age_house_3, "label") <- "Number of individuals in household 40-59 years"
# attr(surveys_scored$Demo_age_house_4, "label") <- "Number of individuals in household 60-74 years"
# attr(surveys_scored$Demo_age_house_5, "label") <- "Number of individuals in household 75 years or older"

```

## QOL (quality of life)
A total score is calculated by adding up the scores for each item. The possible range of scores is 11-55, with higher scores indicating overall better perceived quality of life. It is recommended to examine this scale on both an item level and a total score leval, as items are indicative of specific community needs.
```{r}
surveys_scored <- surveys_scored %>%
  mutate(QOL_tot = rowSums(select(., contains("QOL_"))))

attr(surveys_scored$QOL_tot, "label") <- "Quality of life total score"

```

## SDOH (social determinants of health)
Qualitative in nature; total score is calculated as the total number of endorsements of negative social determinants of health (i.e., responded, "yes", "always","usually""sometimes" or "rarely" to any SDOH items), with higher scores indicating greater endorsement of negative social determinants of health. It is recommended to examine this scale on both an item level and a total score leval, as items are indicative of specific social determinants of health 

```{r}
surveys_scored <- surveys_scored %>%
    dplyr::mutate(across(c(SDOH_1, SDOH_2, SDOH_4:SDOH_6), # recode binary variables into a Boolean
                ~ case_when(
                  . == "No" ~ FALSE,
                  . == "Yes" ~ TRUE,
                  . == "Unsure" ~ NA,
                  . == "I prefer not to answer" ~ NA
                ), 
                .names = "{.col}_R" #add 
              )) %>%
  dplyr::mutate(across(c(SDOH_3, SDOH_7), # recode categorical variables into a Boolean
                ~ case_when(
                  . == "Never" ~ FALSE,
                  . == "I prefer not to answer" ~ NA,
                  !is.na(.) ~ TRUE
                ), 
                .names = "{.col}_R"
              )) %>%
  mutate(SDOH_tot = rowSums(select(., SDOH_1_R:SDOH_7_R)))

attr(surveys_scored$SDOH_tot, "label") <- "social determinants of health total score"
```

## Assets & Barriers
```{r}
# i dont think theres any "scoring" to be done here 
```

## Core Health
Qualitative in nature; total score is calculated as the total number of endorsements of negative health outcomes (i.e., responded, "yes" to any CH items), with higher scores indicating more negative health. It is recommended to examine this scale on both an item level and a total score level, as items are indicative of specific negative health outcomes.
```{r}
surveys_scored <- surveys_scored %>%
  dplyr::mutate(CH_1_R = case_when(CH_1 == "Yes" ~ TRUE, 
                            CH_1 == "Told borderline high or prehypertensive or elevated blood pressure" ~ 1, 
                            CH_1 == "No" ~ FALSE, 
                            CH_1 == "Don’t know / Not sure" ~ NA)) %>%
  dplyr::mutate(across(CH_2:CH_3_15_13, 
                ~ case_when(
                  . == "Yes" ~ TRUE,
                  . == "No" ~ FALSE, 
                  . == "Don’t know / Not sure" ~ NA
                ), 
                .names = "{.col}_R")) %>%
  dplyr::mutate(CH_tot = rowSums(select(., CH_1_R: CH_3_15_13_R)))

attr(surveys_scored$CH_tot, "label") <- "core health total score"
```


## PRBQ (risky behaviors)
Total score is calculated by adding up the scores for each item (PRBQ 1-12). The possible range of scores is 0-48, with higher scores indicating more frequent engagement in risky behaviors. It is recommended to examine this scale on both an item level and a total score level, as items are indicative of engagement with specific risky behaviors.

PRBQ_15 is a global item assessing the level of negative impact of engagement in risky behaviors on ones life
```{r}
surveys_scored <- surveys_scored %>%
  mutate(PRBQ_tot = rowSums(select(., PRBQ_1:PRBQ_12)))

attr(surveys_scored$PRBQ_tot, "label") <- "PRBQ(risky behaviors) total score"

```

## SF-36 (subjective health)
The SF-36 is a measure of subjective health, and assesses eight health concepts: physical functioning, bodily pain, role limitations due to physical health problems, role limitations due to personal or emotional problems, emotional well-being, social functioning, energy/fatigue, and general health perceptions. It also includes a single item that provides an indication of perceived change in health.

Scale	| Number of items |	After recoding average the following items
Physical functioning | 10 | 3 4 5 6 7 8 9 10 11 12
Role limitations due to physical health |	4 |	13 14 15 16
Role limitations due to emotional problems |	3 |	17 18 19
Energy/fatigue	| 4	| 23 27 29 31
Emotional well-being	| 5	| 24 25 26 28 30
Social functioning	| 2	| 20 32
Pain	| 2	| 21 22
General health	| 5 |	1 33 34 35 36
```{r}
col_repl1 <- c("SF36_1", "SF36_2","SF36_20","SF36_22","SF36_34","SF36_36")
surveys_scored[col_repl1] <- lapply(surveys_scored[col_repl1], gsub, pattern = "\\<1\\>", replacement = 100)
surveys_scored[col_repl1] <- lapply(surveys_scored[col_repl1], gsub, pattern = "\\<2\\>", replacement = 75)
surveys_scored[col_repl1] <- lapply(surveys_scored[col_repl1], gsub, pattern = "\\<3\\>", replacement = 50)
surveys_scored[col_repl1] <- lapply(surveys_scored[col_repl1], gsub, pattern = "\\<4\\>", replacement = 25)
surveys_scored[col_repl1] <- lapply(surveys_scored[col_repl1], gsub, pattern = "\\<5\\>", replacement = 0)

col_repl2 <- c("SF36_3", "SF36_4","SF36_5","SF36_6","SF36_7","SF36_8","SF36_9","SF36_10","SF36_11","SF36_12")
surveys_scored[col_repl2] <- lapply(surveys_scored[col_repl2], gsub, pattern = "\\<1\\>", replacement = 0)
surveys_scored[col_repl2] <- lapply(surveys_scored[col_repl2], gsub, pattern = "\\<2\\>", replacement = 50)
surveys_scored[col_repl2] <- lapply(surveys_scored[col_repl2], gsub, pattern = "\\<3\\>", replacement = 100)

col_repl3 <- c("SF36_13", "SF36_14","SF36_15","SF36_16","SF36_17","SF36_18","SF36_19")
surveys_scored[col_repl3] <- lapply(surveys_scored[col_repl3], gsub, pattern = "\\<1\\>", replacement = 0)
surveys_scored[col_repl3] <- lapply(surveys_scored[col_repl3], gsub, pattern = "\\<2\\>", replacement = 100)

col_repl4 <- c("SF36_21", "SF36_23","SF36_26","SF36_27","SF36_30")
surveys_scored[col_repl4] <- lapply(surveys_scored[col_repl4], gsub, pattern = "\\<1\\>", replacement = 100)
surveys_scored[col_repl4] <- lapply(surveys_scored[col_repl4], gsub, pattern = "\\<2\\>", replacement = 80)
surveys_scored[col_repl4] <- lapply(surveys_scored[col_repl4], gsub, pattern = "\\<3\\>", replacement = 60)
surveys_scored[col_repl4] <- lapply(surveys_scored[col_repl4], gsub, pattern = "\\<4\\>", replacement = 40)
surveys_scored[col_repl4] <- lapply(surveys_scored[col_repl4], gsub, pattern = "\\<5\\>", replacement = 20)
surveys_scored[col_repl4] <- lapply(surveys_scored[col_repl4], gsub, pattern = "\\<6\\>", replacement = 0)

col_repl5 <- c("SF36_24", "SF36_25","SF36_28","SF36_29","SF36_31")
surveys_scored[col_repl5] <- lapply(surveys_scored[col_repl5], gsub, pattern = "\\<1\\>", replacement = 0)
surveys_scored[col_repl5] <- lapply(surveys_scored[col_repl5], gsub, pattern = "\\<2\\>", replacement = 20)
surveys_scored[col_repl5] <- lapply(surveys_scored[col_repl5], gsub, pattern = "\\<3\\>", replacement = 40)
surveys_scored[col_repl5] <- lapply(surveys_scored[col_repl5], gsub, pattern = "\\<4\\>", replacement = 60)
surveys_scored[col_repl5] <- lapply(surveys_scored[col_repl5], gsub, pattern = "\\<5\\>", replacement = 80)
surveys_scored[col_repl5] <- lapply(surveys_scored[col_repl5], gsub, pattern = "\\<6\\>", replacement = 100)

col_repl6 <- c("SF36_32", "SF36_33","SF36_35")
surveys_scored[col_repl6] <- lapply(surveys_scored[col_repl6], gsub, pattern = "\\<1\\>", replacement = 0)
surveys_scored[col_repl6] <- lapply(surveys_scored[col_repl6], gsub, pattern = "\\<2\\>", replacement = 25)
surveys_scored[col_repl6] <- lapply(surveys_scored[col_repl6], gsub, pattern = "\\<3\\>", replacement = 50)
surveys_scored[col_repl6] <- lapply(surveys_scored[col_repl6], gsub, pattern = "\\<4\\>", replacement = 75)
surveys_scored[col_repl6] <- lapply(surveys_scored[col_repl6], gsub, pattern = "\\<5\\>", replacement = 100)

#scoring
cols.num <- c("SF36_1", "SF36_2","SF36_20","SF36_22","SF36_34","SF36_36","SF36_3", "SF36_4","SF36_5","SF36_6","SF36_7","SF36_8","SF36_9","SF36_10","SF36_11","SF36_12","SF36_13", "SF36_14","SF36_15","SF36_16","SF36_17","SF36_18","SF36_19",
              "SF36_21", "SF36_23","SF36_26","SF36_27","SF36_30","SF36_24", "SF36_25","SF36_28","SF36_29","SF36_31","SF36_32", "SF36_33","SF36_35")
surveys_scored[cols.num] <- sapply(surveys_scored[cols.num],as.numeric)

surveys_scored$SF36_Physical_functioning <- rowMeans(subset(surveys_scored, select = c("SF36_3", "SF36_4","SF36_5","SF36_6","SF36_7","SF36_8","SF36_9","SF36_10","SF36_11","SF36_12")), na.rm = TRUE)

surveys_scored$SF36_PH_limitations <- rowMeans(subset(surveys_scored, select = c("SF36_13", "SF36_14","SF36_15","SF36_16")), na.rm = TRUE)

surveys_scored$SF36_MH_limitations <- rowMeans(subset(surveys_scored, select = c("SF36_17", "SF36_18","SF36_19")), na.rm = TRUE)

surveys_scored$SF36_Energy <- rowMeans(subset(surveys_scored, select = c("SF36_23", "SF36_27","SF36_29","SF36_31")), na.rm = TRUE)

surveys_scored$SF36_Emotional_WB <- rowMeans(subset(surveys_scored, select = c("SF36_24", "SF36_25","SF36_26","SF36_27","SF36_28","SF36_30")), na.rm = TRUE)

surveys_scored$SF36_Social_funct <- rowMeans(subset(surveys_scored, select = c("SF36_20", "SF36_32")), na.rm = TRUE)

surveys_scored$SF36_Pain <- rowMeans(subset(surveys_scored, select = c("SF36_21", "SF36_22")), na.rm = TRUE)

surveys_scored$SF36_General_Health<- rowMeans(subset(surveys_scored, select = c("SF36_1", "SF36_33","SF36_34","SF36_35","SF36_36")), na.rm = TRUE)

attr(surveys_scored$SF36_Physical_functioning, "label") <- "SF36 physical functioning subscale"
attr(surveys_scored$SF36_PH_limitations, "label") <- "SF36 physical health limitations subscale"
attr(surveys_scored$SF36_MH_limitations, "label") <- "SF36 mental health limitations subscale"
attr(surveys_scored$SF36_Energy, "label") <- "SF36 energy subscale"
attr(surveys_scored$SF36_Emotional_WB, "label") <- "SF36 emotional wellbeing subscale"
attr(surveys_scored$SF36_Social_funct, "label") <- "SF36 social functioning subscale"
attr(surveys_scored$SF36_Pain, "label") <- "SF36 pain subscale"
attr(surveys_scored$SF36_General_Health, "label") <- "SF36 general health subscale"

```

# label

```{r}
# reassign attributions for variables included in the 
for (col_name in varname[multi_resposne_idx]) {
  attributes(surveys_scored[[col_name]]) <- attributes(survey_tidy[[col_name]])
}

# assign the same label to recording variables
for (col_name in c(paste0("SDOH_", 1:7), paste0("CH_3_15_", 1:13),"CH_1", "CH_2")){
  attr(surveys_scored[[paste0(col_name, "_R")]], "label") <- attr(surveys_scored[[col_name]], "label")
}

# reassign labels to sf-36 items
for (col_name in paste0("SF36_", 1:36)) {
  attributes(surveys_scored[[col_name]]) <- attributes(survey_tidy[[col_name]])
}
```


```{r}
#write.csv(surveys_scored, "/Users/kristina/Documents/Surveys/NEW /WHI Exploring Comm Trends/USE THIS/Scored data/WHI_surveys_scored.csv")
scored_dict <- create_dictionary(surveys_scored, remove_repeated = F, use_references = F)
#write.csv(scored_dict, "/Users/kristina/Documents/Surveys/NEW /WHI Exploring Comm Trends/USE THIS/Scored data/DICT_WHI_surveys_scored.csv")

#write.csv(surveys_scored, here("outputs", "whi_data_scored.csv"), row.names = F)
#write.csv(scored_dict, here("outputs", "whi_data_scored_dict.csv"), row.names = F)
```
